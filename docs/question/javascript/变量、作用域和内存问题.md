# 变量、作用域和内存问题
## 1.console.log(null==undefined)为什么输出为true
null和undefined本身在含义上是非常接近的，其实最开始在JavaScript中只有null。后来JavaScript的发明者认为null被当作对象，而表示无的值最好不是对象；同时当时JavaScript没有错误处理机制，如果null自动转为0不容易发现错误。在这两个原因的驱使下，他设计了undefined，并规定：

- null是一个表示无的对象，转为数值的时候为0
- undefined是一个表示无的原始值，转为数值时为NaN

但在实践中，null和undefined基本同义，只有一些小的不同：

- null表示“没有对象”，即此处不该有值。比如：

  - 作为函数的参数，表示该函数的参数不是对象。
  - 作为对象原型链的终点：Object.getPrototypeOf(Object.prototype)
  
- undefined表示“缺少值”，即此处应该有一个值，但是还没有定义。比如：
  
  - 变量声明了，但没有赋值的时候，等于undefined
  - 调用函数时，应该提供的参数没有提供，该参数等于undefined
  - 对象没有赋值的属性，该属性的值为undefined
  - 函数没有返回值时，默认返回undefined   

## 2.介绍一下JavaScript中的垃圾回收机制
### 垃圾回收机制的含义
我们知道，JavaScript对程序执行时候所需内存的分配以及无用内存的回收，均由JavaScript引擎自动管理。其自动回收无用内存的行为我们称之为垃圾回收。垃圾回收机制的核心原理，是JavaScript引擎周期性的寻找那些不再使用的变量，然后释放其占用的内存。
而如何确定变量是否已经无用，在浏览器中的JavaScript引擎有两个策略：
### 标记清楚策略
垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，随后会去掉环境中的变量以及被环境中变量引用的变量的标记，剩下的还有标记的变量将被视为需要删除的变量。确定好需要删除的变量后，垃圾收集器会销毁那些带有标记的值并回收它们所占的内存空间，完成内存清除工作。标记清除（mark-and-sweep）机制也是JavaScript中最常用的垃圾收集方式，2008年以前，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾收集策略，只是在垃圾收集的时间间隔上有所不同。
### 引用计数策略
引用计数（reference counting）策略存在着循环引用的问题，是一个是一个有缺陷的策略，已被Netscape Navigator弃用。之所以存在缺陷，是因为引用计数的主要思想就是跟踪记录每个值被引用的次数：当声明了一个变量并将一个引用类型值赋给该变量，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则没有办法再访问这个值，因而就可以将其占用的内存空间回收。当垃圾收集器下次运行的时候，就会释放那些引用次数为零的值所占用的内存。在这种背景下，如果A对象包含一个指向B对象的指针，而B对象也包含一个指向A对象的引用，就会出现循环引用。

虽然Netscape Navigator已经弃用了引用计数的方式。但是由于在IE中，部分对象并不是原生JavaScript对象。比如BOM和DOM对象就是C++以COM（Component Object Model，组件对象模型）对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略，因此只要在IE中涉及COM对象，就会存在循环引用的问题。例如：
```javascript
var element = document.getElementById("some_anyment");
var myObject = new Object();
myObject.element = element;
element.someObject = myObject;
```
为了解决上述问题，IE9把BOM和DOM对象都转换成了真正的JavaScript对象，这就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄露现象。

### 垃圾回收机制引发的思考
#### 垃圾收集机制的性能问题
由于垃圾收集的工作是周期不间断执行的，如果执行的时间间隔过短，无疑会引起性能问题，特别是在变量分配的内存数量较大的情况下，更会引起严重的性能问题。IE6及以前因其垃圾收集器会频繁运行导致了较坏的影响，IE7调整了其垃圾收集机制，降低了垃圾收集器运行的频率。在IE中，调用window.CollectGarbage()方法会立即执行垃圾收集，在Opera7及更高版本中，调用window.opera.collect（）也会启动垃圾收集程序，但是不建议这么做。

#### 内存管理
虽然JavaScript有垃圾收集机制，内存会被自动回收，但是为了防止运行JavaScript的网页耗尽系统全部内存导致系统崩溃，因此分配给Web浏览器的可用内存相较于桌面应用程序更少。内存的限制会影响给变量分配内存，同时也会影响调用栈以及在一个线程中能够同时执行的语句数量。因此前端开发者有义务保证用最少的内存让页面获得更好的性能。

优化内存的最直接的方式，就是让执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用，如下面这个例子所示：
```javascript
function createPerson(name){ 
    var localPerson = new Object(); 
    localPerson.name = name; 
    return localPerson; 
} 
var globalPerson = createPerson("Nicholas"); 
// 手工解除 globalPerson 的引用 
globalPerson = null; 
```
上例中createPerson函数在执行完后会离开环境，因此无需手动解除引用。但对于全局对象而言，则需要我们在不再使用该变量的时候，手动解除引用。让其脱离执行环境，以便垃圾收集器下次运行时将其回收。

## 3.对this有什么理解

## 4.如何对this进行深拷贝

## 5.bind、apply、call有什么区别

